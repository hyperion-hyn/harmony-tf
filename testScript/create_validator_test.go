package testScript

import (
	"context"
	"encoding/base64"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/ethereum/go-ethereum/staking/types/restaking"
	"github.com/hyperion-hyn/hyperion-tf/accounts"
	"github.com/hyperion-hyn/hyperion-tf/config"
	"github.com/hyperion-hyn/hyperion-tf/crypto"
	sdkAccounts "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/accounts"
	commonRPC "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/network/rpc/common"
	sdkNetworkNonce "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/network/rpc/nonces"
	"github.com/hyperion-hyn/hyperion-tf/extension/go-lib/staking"
	sdkTxs "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/transactions"
	goSdkCommon "github.com/hyperion-hyn/hyperion-tf/extension/go-sdk/pkg/common"
	"github.com/hyperion-hyn/hyperion-tf/extension/go-sdk/pkg/rpc"
	"github.com/hyperion-hyn/hyperion-tf/keys"
	"github.com/hyperion-hyn/hyperion-tf/utils"
	"math/big"
	"testing"
)

func TestCreateValidator(t *testing.T) {

	serverUrl := "http://localhost:8545"

	chain := goSdkCommon.ChainID{"testnet", big.NewInt(7500)}
	rpcClient, err := commonRPC.NewRPCClient(serverUrl)

	//加载默认的account

	privateKey := "e73981bdb56865b580ec228979187f4db3171140b0d1506f5eea4737460a6d31"

	address, err := keys.PrivateKeyToAddress(privateKey)

	var mainAccount sdkAccounts.Account

	if err == nil {
		keyName := utils.PrefixAddress(config.Configuration.Network.Name, address)
		account, err := accounts.ImportPrivateKeyAccount(privateKey, keyName, address)

		if account.Address != "" && err == nil {
			mainAccount = account
		}
	}
	err = mainAccount.Unlock()
	if err != nil {
		panic(fmt.Sprintf("unlock mainAccount %v", err))
	}

	// 创建一个新的账户
	accountName := "CreateValidatorTest"

	account, err := accounts.GenerateAccount(accountName)

	err = account.Unlock()
	if err != nil {
		panic(fmt.Sprintf("unlock account %v", err))
	}

	amount := common.NewDec(1100001)

	currentNonce := sdkNetworkNonce.CurrentNonce(rpcClient, mainAccount.Address)
	fmt.Printf("start transfer money \n")
	//_, err = SendTransaction(serverUrl, &mainAccount, account.Address, amount, -1, 50000, common.NewDec(1), "", 0)

	generatedTx, err := sdkTxs.GenerateTransaction(mainAccount.Address, account.Address, amount, 500000, common.NewDec(1), currentNonce, "")
	if err != nil {
		panic(fmt.Sprintf("unlock account %v", err))
	}

	tx, err := sdkTxs.SignTransaction(mainAccount.Keystore, mainAccount.Account, generatedTx, chain.Value)
	if err != nil {
		panic(fmt.Sprintf("SignTransaction %v", err))
	}

	signature, err := sdkTxs.EncodeSignature(tx)
	if err != nil {
		panic(fmt.Sprintf("EncodeSignature %v", err))
	}
	fmt.Print("wait for 10 second \n")
	receiptHash, err := sdkTxs.SendRawTransaction(rpcClient, signature)
	if err != nil {
		panic(fmt.Sprintf("SendRawTransaction %v", err))
	}

	fmt.Printf("txhash:%v \n", receiptHash)

	balance, err := rpcClient.GetClient().BalanceAt(context.Background(), account.Account.Address, nil)
	if err != nil {
		panic(fmt.Sprintf("transfer money error %v", err))
	}

	fmt.Printf("account %s ,balance :%s \n", account.Account.Address.Hex(), balance.String())

	blsKeys := crypto.GenerateBlsKeys(1, "")

	rate, _ := goSdkCommon.NewDecFromString("0.1")
	maxRate, _ := goSdkCommon.NewDecFromString("0.1")
	maxChangeRate, _ := goSdkCommon.NewDecFromString("0.1")

	currentNonce = sdkNetworkNonce.CurrentNonce(rpcClient, account.Address)

	createValidator := restaking.CreateValidator{
		OperatorAddress: account.Account.Address,
		Description: restaking.Description_{
			Name:            "HarmonyTF_D1_Validator",
			Identity:        "HarmonyTF_D1_Validator",
			Website:         "https://harmony.one",
			SecurityContact: "validator@somewhere.com",
			Details:         "Validator generated by HarmonyTF",
		},
		CommissionRates: restaking.CommissionRates_{
			Rate:          rate,
			MaxRate:       maxRate,
			MaxChangeRate: maxChangeRate,
		},
		MaxTotalDelegation: common.NewDec(1000000).I,
		SlotPubKey:         *blsKeys[0].ShardPublicKey,
		SlotKeySig:         *blsKeys[0].ShardSignature,
		//SlotKeySig: nil, // todo need revert
	}

	fmt.Printf("start create validator \n")

	bytes, err := rlp.EncodeToBytes(createValidator)
	if err != nil {
		panic(fmt.Sprintf("EncodeToBytes %v", err))
	}

	data := base64.StdEncoding.EncodeToString(bytes)

	calculatedGasLimit, err := sdkTxs.CalculateGasLimit(-1, data, true)
	if err != nil {
		panic(fmt.Sprintf("CalculateGasLimit %v", err))
	}

	// todo here add expend more staking price
	gasPrice, _ := big.NewInt(0).SetString("100000000000000000", 10)

	stakingTx := types.NewTransaction(currentNonce, common.BigToAddress(common.Big0), big.NewInt(0), calculatedGasLimit*3, gasPrice, bytes)
	stakingTx.SetType(types.StakeCreateVal)

	signedTx, err := staking.SignStakingTransaction(account.Keystore, account.Account, stakingTx, chain.Value)

	signature, err = sdkTxs.EncodeSignature(signedTx)
	if err != nil {
		panic(fmt.Sprintf("EncodeSignature %v", err))
	}

	receiptHash, err = staking.SendRawStakingTransaction(rpcClient, signature)
	if err != nil {
		panic(fmt.Sprintf("SendRawStakingTransaction %v", err))
	}

	fmt.Printf("create validator result %v", receiptHash)

}

// TransactionPrerequisites - resolves required clients to perform transactions
func TransactionPrerequisites(serverUrl string, account *sdkAccounts.Account, nonce int) (*rpc.HTTPMessenger, uint64, error) {
	rpcClient, err := commonRPC.NewRPCClient(serverUrl)
	if err != nil {
		return nil, 0, err
	}

	var currentNonce uint64
	if nonce < 0 {
		currentNonce = sdkNetworkNonce.CurrentNonce(rpcClient, account.Address)
		if err != nil {
			return nil, 0, err
		}
	} else {
		currentNonce = uint64(nonce)
	}

	return rpcClient, currentNonce, nil
}

func SendTransaction(serverUrl string, account *sdkAccounts.Account, toAddress string, amount common.Dec, nonce int, gasLimit int64, gasPrice common.Dec, txData string, timeout int) (map[string]interface{}, error) {
	account.Unlock()

	rpcClient, currentNonce, err := TransactionPrerequisites(serverUrl, account, nonce)
	if err != nil {
		return nil, err
	}

	if len(txData) > 0 {
		txData = base64.StdEncoding.EncodeToString([]byte(txData))
	}

	txResult, err := sdkTxs.SendTransaction(account.Keystore, account.Account, rpcClient, config.Configuration.Network.API.ChainID, account.Address, toAddress, amount, gasLimit, gasPrice, currentNonce, txData, config.Configuration.Account.Passphrase, config.Configuration.Network.API.NodeAddress(), timeout)

	if err != nil {
		return nil, err
	}

	return txResult, nil
}
